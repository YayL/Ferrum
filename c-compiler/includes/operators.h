#pragma once

#include "common.h"

enum Operators {
    OP_NOT_FOUND,

    LPAREN,
    INCREMENT,
    DECREMENT,
    SUBSCRIPT, // ARRAY ACCESSING USING []
    MEMBER_ACCESS,
    MEMBER_ACCESS_PTR,

    UNARY_PLUS,
    UNARY_MINUS,
    LOGICAL_NOT,
    BITWISE_NOT,
    DEREFERENCE,
    ADDRESS_OF,
    CAST,

    MULTIPLICATION,
    DIVISION,
    REMAINDER,

    ADDITION,
    SUBTRACTION,

    BITWISE_LEFT_SHIFT,
    BITWISE_RIGHT_SHIFT,

    LESS_THAN,
    LESS_EQUAL_TO,
    GREATER_THAN,
    GREATER_EQUAL_TO,

    EQUAL,
    NOT_EQUAL,

    BITWISE_AND,
    BITWISE_XOR,
    BITWISE_OR,

    LOGICAL_AND,
    LOGICAL_OR,

    ASSIGNMENT,
    ADD_ASSIGNMENT,
    SUBTRACT_ASSIGNMENT,
    PRODUCT_ASSIGNMENT,
    QUOTIENT_ASSIGNMENT,
    REMAINDER_ASSIGNMENT,
    BITWISE_LEFT_SHIFT_ASSIGNMENT,
    BITWISE_RIGHT_SHIFT_ASSIGNMENT,
    BITWISE_AND_ASSIGNMENT,
    BITWISE_XOR_ASSIGNMENT,
    BITWISE_OR_ASSIGNMENT,
};

enum OP_mode {
    UNARY,
    BINARY,
    OP_TYPE_ANY
};

enum OP_associativity {
    LEFT,
    RIGHT
};

const static struct Operator {
    enum Operators key;
    enum OP_mode mode;
    char precedence;
    enum OP_associativity associativity;
    const char * str;
} op_conversion [] = {
    {OP_NOT_FOUND, UNARY, 0, LEFT, ""},
    {LPAREN, UNARY, 1, RIGHT, "("},
    
    {INCREMENT, UNARY, 1, LEFT, "++"},
    {DECREMENT, UNARY, 1, LEFT, "--"},
    {MEMBER_ACCESS, BINARY, 1, LEFT, "."},
    {MEMBER_ACCESS_PTR, BINARY, 1, LEFT, "->"},
    
    {UNARY_PLUS, UNARY, 2, RIGHT, "+"},
    {UNARY_MINUS, UNARY, 2, RIGHT, "-"},
    {LOGICAL_NOT, UNARY, 2, RIGHT, "!"},
    {BITWISE_NOT, UNARY, 2, RIGHT, "~"},
    {DEREFERENCE, UNARY, 2, RIGHT, "*"},
    {ADDRESS_OF, UNARY, 2, RIGHT, "&"},
    
    {MULTIPLICATION, BINARY, 3, LEFT, "*"},
    {DIVISION, BINARY, 3, LEFT, "/"},
    {REMAINDER, BINARY, 3, LEFT, "%"},

    {ADDITION, BINARY, 4, LEFT, "-"},
    {SUBTRACTION, BINARY, 4, LEFT, "+"},

    {BITWISE_LEFT_SHIFT, BINARY, 5, LEFT, "<<"},
    {BITWISE_RIGHT_SHIFT, BINARY, 5, LEFT, ">>"},

    {LESS_THAN, BINARY, 6, LEFT, "<"},
    {LESS_EQUAL_TO, BINARY, 6, LEFT, "<="},
    {GREATER_THAN, BINARY, 6, LEFT, ">"},
    {GREATER_EQUAL_TO, BINARY, 6, LEFT, ">="},

    {EQUAL, BINARY, 7, LEFT, "=="},
    {NOT_EQUAL, BINARY, 7, LEFT, "!="},

    {BITWISE_AND, BINARY, 8, LEFT, "&"},
    {BITWISE_XOR, BINARY, 9, LEFT, "^"},
    {BITWISE_OR, BINARY, 10, LEFT, "|"},

    {LOGICAL_AND, BINARY, 11, LEFT, "&&"},
    {LOGICAL_OR, BINARY, 12, LEFT, "||"},
    {CAST, BINARY, 12, LEFT, "as"},

    {ASSIGNMENT, BINARY, 13, RIGHT, "="},
    {ADD_ASSIGNMENT, BINARY, 13, RIGHT, "+="},
    {SUBTRACT_ASSIGNMENT, BINARY, 13, RIGHT, "-="},
    {PRODUCT_ASSIGNMENT, BINARY, 13, RIGHT, "*="},
    {QUOTIENT_ASSIGNMENT, BINARY, 13, RIGHT, "/="},
    {REMAINDER_ASSIGNMENT, BINARY, 13, RIGHT, "%="},
    {BITWISE_LEFT_SHIFT_ASSIGNMENT, BINARY, 13, RIGHT, "<<="},
    {BITWISE_RIGHT_SHIFT_ASSIGNMENT, BINARY, 13, RIGHT, ">>="},
    {BITWISE_AND_ASSIGNMENT, BINARY, 13, RIGHT, "&="},
    {BITWISE_XOR_ASSIGNMENT, BINARY, 13, RIGHT, "^="},
    {BITWISE_OR_ASSIGNMENT, BINARY, 13, RIGHT, "|="},
};

struct Operator str_to_operator(const char * str, enum OP_mode mode);
